## 列表 List

##### 容器序列与扁平序列

​		列表为为数不多的可变序列，可以存放不同类型的数据，也被称为容器序列。容器序列中存放的是它们所包含的任意类型的对象的**引用**。（如list，tuple，collections.deque等）

​		而扁平序列中存放的是值而不是引用，所以扁平序列只能容纳一种类型。扁平序列实际上是一段连续的内存空间，也因此扁平序列中的内容更加紧凑。（如str，bytes等）

##### 列表推导

​		列表推导是构建列表的快捷方式，是列表类型的生成器表达式。具有可读性强，效率高的特点。如：

```python
# 将字符串变成Unicode码位列表
symbols = '@#$%&'
codes = [ord(symbol) for symbol in symbols] # 列表推导
print(codes)
```

得到的结果为：

```python
[64, 35, 36, 37, 38]
```

​		列表推导最重要的作用就是简化代码，使代码看起来更简洁

##### 生成器表达式

​		生成器表达式的原理与列表推导相同，遵守迭代器的协议，逐个产出元素。而不是先建立一个完整的列表，然后把列表传递到某个构造函数中。使用生成器表达式显然可以节省内存。其语法与列表推导相似，只是把[ ]换成了( )。当需要迭代生成元组，数组或其他数据类型时，使用生成器表达式是个更好的选择。

例如，利用生成器表达式计算笛卡尔积：

```python
colors = ['black', 'white']
sizes = ['S', 'M', 'L']
for tshirt in ('%s %s' % (c, s) for c in colors for s in sizes):
    print(tshirt)
```

得到的结果为：

```python
black S
black M
black L
white S
white M
white L
```

​		生成器表达式会逐个产出元素，而不是一次性产出一个含有6个元素的列表。

##### 列表排序

​		列表排序常用的两个方法：

​		list.sort：就地排序列表，不产生新的列表，返回值为None。

​		sorted()函数：新建一个列表，将原列表传入，排序。返回值为新列表。（接受任何形式的可迭代对象作为参数）

​		两种方法都有两个可选参数：

​		reverse：设为True时，序列中的元素降序输出。默认为False。

​		key：一个只有一个参数的函数，这个函数将用于序列里的每一个元素，所产生的结果将作为排序算法的依赖关键字。如：key=str.lower时，实现忽略大小写的排序。key=len时，进行基于字符串长度的排序。

##### 切片原理

​		切片操作与实例的 __ getitem __ 方法有关，例如：

```python
class MySeq:
    def __getitem__(self,index):
        return index
s = MySeq()
s[1]			#output 1
s[1:4]			#output slice(1,4,None)
s[1:4:2]		#output slice(1,4,2)
s[1:4:2,9]		#output (slice(1,4,2),9)
s[1:4:2,7:9]	#output (slice(1,4,2),slice(7,9,None))
```

​		其中，slice(1,4,2)的意思是从1开始，到4结束，步长为2。但是当 [ ] 中出现逗号时，__ getitem __ 收到的是一个**元组**，甚至元组中可以有多个切片对象。

​		slice类中有一个特别的属性：indices。它可以处理缺失索引和负数索引，以及长度超过目标序列的切片。

## 元组Tuple

​		元组除了用作不可变列表这一作用，还有用于没有字段名的记录的作用。

##### 元组的记录与拆包

​		元组除了记录一个字段的数据，还有这个数据在元组中的位置。数据的位置信息正是这个数据在元组中的意义。

​		而元组的拆包通常使用for循环迭代整个元组实现。将多个元组中某个位置的值赋给变量。

##### 具名元组

​		具名元组(namedtuple)是一个函数，在collections库中，可以用来构建一个带字段名的元组和一个有名字的类，这使得元组的可读性大大提高。例如：

```python
import collections.namedtuple
#卡牌元组，记录卡牌的点数和花色
card = collections.namedtuple('Card', ['rank', 'suit']) 
```

​		可见，建立一个具名元组需要两个参数，元组名和各个字段的名字。后者可以是由数个字符串构成的可迭代对象，或者是由**空格**分开的字段名组成的字符串。

##### 相对不可变性

​		元组与多数Python集合一样，保存的是对象的引用。**如果引用的元素是可变的，即便元组本身不可变，元素依然可变**。所以，元组的不可变指的是**元组数据结构中的物理内容（即保存的引用）不变**，与引用的对象无关。

## 字典Dict

​		字典类型是一种键值的映射关系集合，只有**可散列**的数据类型才能作为映射中的键。

##### 可散列类型

​		如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且需要实现__ hash __ ()方法。另外，可散列对象还要有 __ eq __()方法，为了与其他键做比较。

​		原子不可变数据类型（如str，bytes和数值类型）都是可散列类型。对于元组，当元组所包含的所有元素都是可散列类型的情况下，它才是可散列的。列表List显然是不可散列的。

###### 散列表

​		散列表是dict类型实现的关键。实际上，散列表是一个**稀疏数组**，散列表中的单元叫**表元**，在dict的散列表中，每一个键值对都占用一个表元，每个表元都有两部分：对键的引用和对值的引用。**因为所有表元的大小相同，可以通过偏移量来访问表元。**

​		字典中的数据由于键可散列，效率高得离谱。但是由于需要单独存储散列表，而散列表又是稀疏的，导致空间上的效率低下，使得字典的内存开销巨大。

###### 散列表算法

​		为了获取my_dict[search_key]的值，Python首先会调用hash( )函数计算search_key的散列值（简称hash值）。把这个值的最低几位数字作为偏移量，在散列表中查找**表元**。若表元为空，则报错KeyError，若不为空，表元中会有一对found_key:found_value。此时Python会检验search_key == found_key 是否为True，若相等，则返回found_value。

​		若不相等，则证明存在**散列冲突**（散列冲突的本质是随机性的巧合）。为了解决冲突，算法会在刚刚的hash值中另外取几位，经处理后再做索引寻找表元，并重复上述判断步骤。

​		同样因为散列冲突的存在，最好不要对字典同时进行迭代和修改。无论何时往字典中添加新的键，Python解释器都会新建一个散列表，然后把字典中的元素写入。这个过程中可能会改变原来的散列冲突，或者产生新的散列冲突，导致新散列表中键的次序变化。


