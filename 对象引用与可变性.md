## 对象引用

### 标识与别名

​		Python中的变量是**引用型变量**。给Python中的变量赋值，就像是为对象贴上**标注**（类似于指针，保存对象在内存中的地址）。如果给一个对象贴上多个标注，这些标注就是**别名**。

```python
a = [1,2,3]
b = a
a.append(4)
print(b)	#outputs [1,2,3,4]
```

​		其中，变量a是列表对象的标注，b就是a的别名。在一个赋值语句中，对象在右边创建或获取，之后左边的变量才会绑定到对象上。所以读一条赋值语句应该先读右边。

### 相等性

​		别名之间最大的特点，就是id( )函数返回值相同，并且值相同。但是在比较值时使用‘==’运算符，会调用__ eq __ 方法，该方法会判断值是否相等，但是不能确定二者绑定了同一个对象，例如：

```python
charles = {'name':'Charles', 'born':1832}
lewis = charles		#lewis是charles的别名
lewis is charles	#output True
alex = {'name':'Charles', 'born':1832}	#定义alex，内容与charles相同
alex == charles		#output True
alex is not charles		#output True
```

总结来说：‘==’运算符比较值，is比较对象的标识。is运算符比‘==’速度更快

### 浅复制和深复制

​		使用构造方法或[ : ]创建副本的行为是**浅复制**，即只复制了最外层的容器，副本中的元素是原容器中元素的**引用**。

一个浅复制的例子：

```python
L1 = [3,[66,55,44],(7,8,9)]
L2 = list(L1)	#L2为L1的浅复制
L1.append(100)	#把100追加到L1中，对L2没有影响
L1[1].remove(55)	#把L1内部列表中的数据删除会影响L2，因为它们都是对同一个列表的引用
print('L1',L1)	#output L1:[3,[66,44],(7,8,9),100]
print('L2',L2)	#output L2:[3,[66,44],(7,8,9)]
L2[1] += [33,22]	#对L2中可变类型进行修改，会影响L1,因为都是同一个引用
L2[2] += (10,11)	#对L2中不可变类型进行修改则不会影响，因为‘+=’运算符创建了一个新对象
print('L1',L1)	#output L1:[3,[66,44,33,22],(7,8,9),100]
print('L2',L2)	#output L2:[3,[66,44,33,22],(7,8,9,10,11)]
```

​		对于深复制，即副本不共享内部对象的引用。通常使用copy模块中的deepcopy( )函数和copy( )函数，可以对任意对象做深复制或浅复制。最容易分辨两种复制的方法就是使用id( )函数。

## 函数参数引用

​		Python只支持共享传参（形参，实参结构），函数可能会修改作为参数传入的可变对象，但无法修改那些对象的标识。在Python参数中，可选参数可以有默认值，但是应该**避免使用可变的对象（如列表）作为参数的默认值**。

### 防御可变参数

​		如果定义的函数接收可变参数，那么应该考虑调用方法是否期望修改传入的参数。在类中直接把参数赋值给实例变量，会为参数对象创建别名，这样会导致很多问题。最好的方法是**创建副本**。

